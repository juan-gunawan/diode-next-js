{"version":3,"file":"static/development/pages/index.js","sources":["webpack:///webpack/bootstrap","webpack:///./components/ImageDisplay.js","webpack:///./pages/index.js","webpack:///./queries/ImageDisplayQuery.js","webpack:///./react-diode/src/DiodePublic.js","webpack:///./react-diode/src/cache/DiodeCache.js","webpack:///./react-diode/src/container/DiodeContainer.js","webpack:///./react-diode/src/container/DiodeRootContainer.js","webpack:///./react-diode/src/container/resolveContainerProps.js","webpack:///./react-diode/src/network/DiodeNetworkLayer.js","webpack:///./react-diode/src/query/DiodeContainerQuery.js","webpack:///./react-diode/src/query/DiodeQueryRequest.js","webpack:///./react-diode/src/query/DiodeQueryTypes.js","webpack:///./react-diode/src/query/DiodeRootQuery.js","webpack:///./react-diode/src/query/createBatchQueryRequest.js","webpack:///./react-diode/src/query/createDiodeQuery.js","webpack:///./react-diode/src/query/filterBatchQuery.js","webpack:///./react-diode/src/query/resolveBatchQuery.js","webpack:///./react-diode/src/query/resolvePendingQueries.js","webpack:///./react-diode/src/query/resolveQueryResponse.js","webpack:///./react-diode/src/store/DiodeStore.js","webpack:///./utils/DefaultDiodeNetworkLayer.js","webpack:///external \"@babel/runtime/regenerator\"","webpack:///external \"axios\"","webpack:///external \"deep-extend\"","webpack:///external \"hoist-non-react-statics\"","webpack:///external \"lodash.find\"","webpack:///external \"object-assign\"","webpack:///external \"react\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = require('../../../ssr-module-cache.js');\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tvar threw = true;\n \t\ttry {\n \t\t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n \t\t\tthrew = false;\n \t\t} finally {\n \t\t\tif(threw) delete installedModules[moduleId];\n \t\t}\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import React, { Component } from 'react';\n// import Diode from 'react-diode';\nimport Diode from '../react-diode/src/DiodePublic';\nimport ImageDisplayQuery from '../queries/ImageDisplayQuery';\n// import ContentResourceQuery from '../queries/ContentResourceQuery';\n\nclass ImageDisplay extends Component {\n  render() {\n    console.log(this.props);\n    return (\n      <div>\n        { }\n      </div>\n    );\n  }\n}\n\nexport default Diode.createRootContainer(ImageDisplay, {\n  children: [],\n  queries: {\n    fetchImage: Diode.createQuery(ImageDisplayQuery, {\n      image: 'fragment',\n    }),\n    // contentResource: Diode.createQuery(ContentResourceQuery, {\n    //   hello: {\n    //     world: null,\n    //   },\n    // }),\n  },\n}); \n","import React from 'react';\n// import Diode from 'react-diode';\nimport Diode from '../react-diode/src/DiodePublic';\n\n// Component\nimport ImageDisplay from '../components/ImageDisplay';\n\n// Diode\nimport DiodeNetworkLayer from '../utils/DefaultDiodeNetworkLayer';\n// import CRNetworkLayer from '../utils/FakeNetworkLayer';\n\nDiode.injectNetworkLayer(new DiodeNetworkLayer(''));\n// Diode.injectNetworkLayer(new CRNetworkLayer());\n\nclass Home extends React.Component {\n  static async getInitialProps(ctx) {\n    if (ctx.req) {\n      // Diode setup\n      const cache = await Diode.Store.forceFetch(ImageDisplay);\n\n      return { \n        cache,\n        isServer: true, \n      };\n\n      return {};\n    }\n    \n    return { cache: window.__NEXT_DATA__.props.pageProps.cache, isServer: false };\n  }\n\n  constructor(props) {\n    super(props);\n\n    const cache = props.cache;\n\n    if (!props.isServer && !props.cache) {\n      cache = window.__NEXT_DATA__.props.pageProps.cache\n    }\n\n    this.cache = Diode.createCache(cache);\n    // this.cache = Diode.createCache({});\n  }\n\n  render () {\n    return (\n      <div>\n        <Diode.CacheProvider value={this.cache}> \n          <ImageDisplay />\n        </Diode.CacheProvider>\n      </div>\n    );\n  }\n}\n\nexport default Home;\n","// import Diode from 'react-diode';\nimport Diode from '../react-diode/src/DiodePublic';\n\nexport default {\n  type: 'fetchImage',\n  request(fragment, params, options) {\n    const url = `https://jsonplaceholder.typicode.com/photos`;\n    const method = 'get';\n\n    const payload = '';\n\n    return Diode.queryRequest(url, method, payload);\n  },\n  resolve(response, fragment, options) {\n    return response.data;\n  },\n};\n","import { CacheContext, createCache } from \"./cache/DiodeCache\";\nimport DiodeStore from \"./store/DiodeStore\";\nimport { createContainer } from \"./container/DiodeContainer\";\nimport { createRootContainer } from \"./container/DiodeRootContainer\";\nimport DiodeQueryTypes from \"./query/DiodeQueryTypes\";\nimport { createDiodeQuery } from \"./query/createDiodeQuery\";\nimport {\n  createQueryRequest,\n  createPendingQueryRequest\n} from \"./query/DiodeQueryRequest\";\n\nconst DiodePublic = {\n  Store: DiodeStore,\n  CacheProvider: CacheContext.Provider,\n  QueryTypes: DiodeQueryTypes,\n\n  createCache,\n  createContainer,\n  createRootContainer,\n  createQuery: createDiodeQuery,\n  queryRequest: createQueryRequest,\n  waitForQuery: createPendingQueryRequest,\n  useBatchQuery: DiodeStore.useBatchQuery.bind(DiodeStore),\n  useMockQueries: DiodeStore.useMockQueries.bind(DiodeStore),\n  injectNetworkLayer: DiodeStore.injectNetworkLayer.bind(DiodeStore)\n};\n\nexport default DiodePublic;\n","import React from \"react\";\nimport Store from \"../store/DiodeStore\";\n\nexport const CacheContext = React.createContext(null);\n\nexport const FETCH_ALL_CACHE = \"__fac__\";\n\nexport class DiodeCache {\n  constructor(cache, options) {\n    Store.cache = cache;\n    Store.options = options;\n  }\n\n  getContents() {\n    return Store.cache;\n  }\n\n  // TODO memo\n  getUnresolvedQueries(containerQuery) {\n    return Object.keys(containerQuery.map).filter(type => {\n      const cache = Store.cache[type];\n      if (!cache) {\n        // have no matching cache\n        return true;\n      }\n\n      // check for unresolved fragment\n      const query = containerQuery.map[type];\n      return Object.keys(query.fragmentStructure).some(fragment => {\n        const cachedFragment = cache[fragment];\n        const innerFragmentKeys = Object.keys(\n          query.fragmentStructure[fragment]\n        );\n\n        if (innerFragmentKeys.length === 0) {\n          if (cachedFragment && typeof cachedFragment === \"object\") {\n            // might already cache fetch-all\n            return !cachedFragment[FETCH_ALL_CACHE];\n          }\n\n          return cachedFragment === undefined;\n        }\n\n        return innerFragmentKeys.some(key => {\n          // API can return null\n          if (cachedFragment) {\n            return cachedFragment[key] === undefined;\n          }\n\n          return cachedFragment === undefined;\n        });\n      });\n    });\n  }\n\n  hasResolved(containerQuery) {\n    return this.getUnresolvedQueries(containerQuery).length === 0;\n  }\n\n  async resolve(containerQuery) {\n    await Store.fetch(containerQuery);\n  }\n}\n\nexport function createCache(initialCache, options) {\n  return new DiodeCache(initialCache, options);\n}\n","/**\n * @flow\n */\nimport React from \"react\";\nimport deepExtend from \"deep-extend\";\nimport objectAssign from \"object-assign\";\nimport hoistStatics from \"hoist-non-react-statics\";\nimport DiodeContainerQuery from \"../query/DiodeContainerQuery\";\nimport { CacheContext } from \"../cache/DiodeCache\";\n\nclass DiodeQueryFetcher extends React.Component {\n  state = {\n    error: null,\n    loading: true\n  };\n\n  async componentDidMount() {\n    const { cache, query } = this.props;\n\n    // prevent re-renders ?\n    if (cache.hasResolved(query)) {\n      return;\n    }\n\n    try {\n      await cache.resolve(query);\n      this.setState({ loading: false });\n    } catch (error) {\n      console.error(\"error\", error);\n      this.setState({ error, loading: false });\n    }\n  }\n\n  render() {\n    const { Component, wrapper, cache, query, ...props } = this.props;\n\n    if (this.state.error !== null) {\n      // TODO error handling\n      return <span>{this.state.error.message}</span>;\n    }\n\n    const resolved = cache.hasResolved(query);\n    const loading = !resolved && this.state.loading;\n\n    const component = loading ? // TODO async handling\n    null : (\n      <Component {...props} {...cache.getContents()} />\n    );\n\n    if (wrapper) {\n      return <div {...wrapper}>{component}</div>;\n    }\n\n    return component;\n  }\n}\n\nfunction createContainerComponent(Component, spec, query) {\n  /* istanbul ignore next */\n  const componentName = Component.displayName || Component.name;\n  const containerName = `Diode(${componentName})`;\n\n  class DiodeContainer extends React.Component {\n    constructor(props) {\n      super(props);\n      this.wrapperInfo = spec.wrapperInfo;\n    }\n\n    render() {\n      const { props, wrapperInfo } = this;\n      const wrapper = props.wrapperInfo ? props.wrapperInfo : wrapperInfo;\n\n      return (\n        <CacheContext.Consumer>\n          {cache => {\n            return (\n              <DiodeQueryFetcher\n                {...this.props}\n                Component={Component}\n                wrapper={wrapper}\n                query={query}\n                cache={cache}\n              />\n            );\n          }}\n        </CacheContext.Consumer>\n      );\n    }\n  }\n\n  DiodeContainer.displayName = containerName;\n  return hoistStatics(DiodeContainer, Component);\n}\n\nexport function createContainer(\n  Component,\n  spec = {}\n) {\n  /* istanbul ignore next */\n  const componentName = Component.displayName || Component.name;\n  const containerName = `Diode(${componentName})`;\n  const query = new DiodeContainerQuery(\n    componentName,\n    spec.queries,\n    spec.children\n  );\n\n  let Container;\n  function ContainerConstructor(props) {\n    /* istanbul ignore else */\n    if (!Container) {\n      Container = createContainerComponent(Component, spec, query);\n    }\n    return new Container(props);\n  }\n\n  ContainerConstructor.setWrapperInfo = function setWrapperInfo(wrapperInfo) {\n    objectAssign(spec.wrapperInfo, wrapperInfo);\n  };\n\n  ContainerConstructor.getWrapperInfo = function getWrapperInfo(key) {\n    return spec.wrapperInfo[key];\n  };\n\n  ContainerConstructor.getComponent = function getComponent() {\n    return Component;\n  };\n\n  ContainerConstructor.getChildren = function getChildren() {\n    if (spec.children && spec.children.length) {\n      return spec.children;\n    } else {\n      return [];\n    }\n  };\n\n  ContainerConstructor.query = deepExtend(query, Component.query);\n  ContainerConstructor.displayName = containerName;\n  ContainerConstructor.componentName = componentName;\n\n  return hoistStatics(ContainerConstructor, Component, { query: true });\n}\n","/**\n * @flow\n */\nimport DiodeRootQuery from \"../query/DiodeRootQuery\";\nimport { createContainer } from \"./DiodeContainer\";\n\nexport function createRootContainer(\n  Component,\n  spec\n) {\n  const Container = createContainer(Component, spec);\n  Container.query = new DiodeRootQuery(Container.query);\n  return Container;\n}\n","import objectAssign from \"object-assign\";\n\nexport default function resolveContainerProps(\n  response,\n  RootContainer\n) {\n  // Convert diode response as root container props\n  const { map: queryMap } = RootContainer.query.getContainerQuery();\n  const containerProps = Object.keys(queryMap).reduce((props, key) => {\n    props[key] = response[queryMap[key].type];\n    return props;\n  }, {});\n\n  const { __additional } = response;\n  if (__additional) {\n    return objectAssign(containerProps, { __additional });\n  } else {\n    return containerProps;\n  }\n}\n","/**\n * @flow\n */\nimport objectAssign from \"object-assign\";\n\nclass DiodeNetworkLayer {\n  _injectedNetworkLayer;\n\n  _queryMockEnabled;\n\n  constructor() {\n    this._queryMockEnabled = false;\n  }\n\n  /**\n   * @internal\n   *\n   * Supply your own network layer\n   */\n  injectNetworkLayer(networkLayer) {\n    this._injectedNetworkLayer = networkLayer;\n  }\n\n  injectQueryMockResolver(queryMockResolver) {\n    this._queryMockEnabled = true;\n    this._queryMockResolver = queryMockResolver;\n  }\n\n  /**\n   * @internal\n   *\n   * Send diode query via injected network layer\n   */\n  sendQueries(queries, options) {\n    let queryRequests = queries;\n    const mockedQueryResponse = {};\n    const networkLayer = this._getCurrentNetworkLayer();\n\n    if (this._queryMockEnabled) {\n      queryRequests = queries.filter(query => {\n        // check whether a query as a mocked response\n        const queryMockResolver = this._queryMockResolver[query.type];\n        if (queryMockResolver && typeof queryMockResolver === \"function\") {\n          const mockedResponse = queryMockResolver(query);\n          if (mockedResponse) {\n            mockedQueryResponse[query.type] = mockedResponse;\n            return false;\n          }\n          {\n            return true;\n          }\n        } else {\n          return true;\n        }\n      });\n    }\n\n    return networkLayer.sendQueries(queryRequests, options).then(response => {\n      return objectAssign(mockedQueryResponse, response);\n    });\n  }\n\n  _getCurrentNetworkLayer() {\n    return this._injectedNetworkLayer;\n  }\n}\n\nexport default DiodeNetworkLayer;\n","/**\n * @flow\n */\nimport deepExtend from \"deep-extend\";\n\n/**\n * Partially-complete query in given DiodeContainer\n *\n */\nclass DiodeContainerQuery {\n  // store final query shape\n  map = {};\n\n  // store distinct query type\n  _queryTypeMap = {};\n\n  _queries;\n\n  _children;\n\n  constructor(\n    componentName,\n    queries,\n    children\n  ) {\n    this._componentName = componentName;\n    this._queries = queries;\n    this._children = children || [];\n\n    this._parseQueryTypeMap(queries);\n    this._mergeChildQueryTypeMap(children);\n    this._buildFinalQueryMap(queries, children);\n  }\n\n  getQueryTypeMap() {\n    return this._queryTypeMap;\n  }\n\n  /**\n   * @internal\n   * @unstable\n   *\n   * Add child container dynamicly and rebuilt the query map\n   */\n  injectChildren(children) {\n    this._children = this._children.concat(children);\n    this._mergeChildQueryTypeMap(children);\n    this._buildFinalQueryMap(this._queries, this._children);\n  }\n\n  /**\n   * Group distinct query type into single query shape, this is to make sure\n   * there is no same query type with different key.\n   */\n  _parseQueryTypeMap(queries) {\n    if (queries === null || queries === undefined) {\n      return;\n    }\n\n    Object.keys(queries).forEach(key => {\n      const query = queries[key];\n      const existingQueryType = this._queryTypeMap[query.type];\n\n      if (existingQueryType) {\n        const { fragmentStructure: existingFragment } = existingQueryType;\n        const { fragmentStructure: newFragment } = query;\n        deepExtend(existingFragment, newFragment);\n        deepExtend(existingQueryType.params, query.params);\n      } else if (query.type) {\n        this._queryTypeMap[query.type] = query;\n      } else {\n        throw new Error(\n          `Invalid query type in query key ${key} at component ${\n            this._componentName\n          }`\n        );\n      }\n    });\n  }\n\n  /**\n   * Merge all child query map with existing query map, also merge all queries\n   * with same type as we can have different key between parent-child that\n   * represent same query type\n   */\n  _mergeChildQueryTypeMap(children) {\n    if (!children || !children.length) {\n      return;\n    }\n\n    children.forEach(child => {\n      const childQueryMap = child.query.map;\n\n      /* istanbul ignore if */\n      if (childQueryMap === null || childQueryMap === undefined) {\n        return;\n      }\n\n      Object.keys(childQueryMap).forEach(key => {\n        const childQuery = childQueryMap[key];\n        const existingQueryType = this._queryTypeMap[childQuery.type];\n\n        if (existingQueryType) {\n          const { fragmentStructure: existingFragment } = existingQueryType;\n          const { fragmentStructure: newFragment } = childQuery;\n          deepExtend(existingFragment, newFragment);\n        } else {\n          this._queryTypeMap[childQuery.type] = childQuery;\n        }\n      });\n    });\n  }\n\n  /**\n   * Given complete query type map from current container and child container,\n   * re-generate query map from initial queries with the complete query\n   */\n  _buildFinalQueryMap(\n    queries,\n    children\n  ) {\n    if (queries) {\n      // Create initial query map from parent container via query type map.\n      // For the most part, this is enough as we already compile the complete\n      // fragment and usually parent and child use same query key\n      this.map = Object.keys(queries).reduce((queryMap, key) => {\n        const query = queries[key];\n        queryMap[key] = this._queryTypeMap[query.type];\n        return queryMap;\n      }, {});\n    }\n\n    if (!children || !children.length) {\n      return;\n    }\n\n    children.forEach(child => {\n      const queryMap = child.query.map;\n\n      Object.keys(queryMap).forEach(key => {\n        const childQuery = queryMap[key];\n        const existingQuery = this.map[key];\n\n        if (existingQuery && existingQuery.type !== childQuery.type) {\n          return console.warn(\n            // eslint-disable-line no-console\n            \"Different query type for same query key %s: %s (%s) and %s (%s)\",\n            key,\n            this._componentName,\n            existingQuery.type,\n            child.componentName,\n            childQuery.type\n          );\n        }\n\n        this.map[key] = this._queryTypeMap[childQuery.type];\n      });\n    });\n  }\n}\n\nexport default DiodeContainerQuery;\n","/**\n * @flow\n */\n\n/**\n * @public\n *\n */\nexport function createPendingQueryRequest(\n  QueryDependencies,\n  callback\n) {\n  if (!(QueryDependencies instanceof Array)) {\n    QueryDependencies = [QueryDependencies];\n  }\n\n  return {\n    pending: true,\n    dependencies: QueryDependencies,\n    callback\n  };\n}\n\n/**\n * @public\n *\n */\nexport function createQueryRequest(\n  url,\n  method,\n  payload,\n  headers = {}\n) {\n  return {\n    pending: false,\n    url,\n    method,\n    payload,\n    headers\n  };\n}\n\n/**\n * @internal\n *\n */\nexport function getQueryRequests(\n  RootContainer,\n  options\n) {\n  const queries = RootContainer.query.compile();\n\n  return queries.map(query => {\n    const { fragment, params } = query;\n    const queryRequestInfo = query.request(fragment, params, options);\n    return generateQueryRequest(query, queryRequestInfo);\n  });\n}\n\n/**\n * @internal\n *\n * Generate query request to be sent via sendQueries\n */\nexport function generateQueryRequest(\n  query,\n  queryRequestInfo\n) {\n  const { type, fragment, resolve } = query;\n\n  return {\n    type,\n    fragment,\n    resolve,\n    ...queryRequestInfo\n  };\n}\n","const DiodeQueryTypes = {\n  BATCH: \"batch-query\"\n};\n\nexport default DiodeQueryTypes;\n","/**\n * @flow\n */\nimport deepExtend from \"deep-extend\";\n\n/**\n * Represent complete query in Diode.RootContainer\n *\n */\nclass DiodeRootQuery {\n  _variables;\n  _containerQuery;\n\n  constructor(containerQuery) {\n    this._containerQuery = containerQuery;\n  }\n\n  /**\n   * @internal\n   *\n   */\n  getContainerQuery() {\n    return this._containerQuery;\n  }\n\n  /**\n   * @public\n   *\n   */\n  setVariables(variables) {\n    deepExtend(this._variables, variables);\n  }\n\n  /**\n   * @public\n   *\n   */\n  getVariables() {\n    return this._variables;\n  }\n\n  /**\n   * @public\n   *\n   * Compile query map into an array of actionable query and apply fragment\n   * values from .setVariables() method (if any)\n   */\n  compile() {\n    const queryTypeMap = this._containerQuery.getQueryTypeMap();\n\n    return Object.keys(queryTypeMap).map(queryType => {\n      const query = queryTypeMap[queryType];\n      query.fragment = this._compileFragmentKeys(query.fragmentStructure);\n      query.params = this._compileFragmentKeys(query.paramsStructure);\n      return query;\n    });\n  }\n\n  /**\n   * Iterate over fragment structure keys and compile the value.\n   * If an object is found, recursively iterate the object keys\n   */\n  _compileFragmentKeys(rawFragment) {\n    return Object.keys(rawFragment).reduce((fragment, key) => {\n      const parsedKey = this._compileFragmentValue(key);\n\n      // typeof null === 'object'\n      if (typeof rawFragment[key] === \"object\" && rawFragment[key] !== null) {\n        fragment[parsedKey] = this._compileFragmentKeys(rawFragment[key]);\n      } else {\n        fragment[parsedKey] = this._compileFragmentValue(rawFragment[key]);\n      }\n\n      return fragment;\n    }, {});\n  }\n\n  /**\n   * Replace value format with actual value from stored value map\n   */\n  _compileFragmentValue(rawFragment) {\n    if (typeof rawFragment === \"string\" && rawFragment.charAt(0) === \"$\") {\n      const key = rawFragment.slice(1);\n      const value = this._variables[key];\n\n      // If value not found from value map, return as is.\n      // Do not use boolean coercion here as it's possible we have\n      // falsy value like 0 and ''\n      if (typeof value === \"undefined\" || value === null) {\n        return rawFragment;\n      }\n\n      return value;\n    }\n\n    return rawFragment;\n  }\n}\n\nexport default DiodeRootQuery;\n","export default function createBatchQueryRequest(\n  query,\n  queryList,\n  options\n) {\n  const { resolve, type } = query;\n\n  return {\n    type,\n    resolve,\n    ...query.request(queryList, options)\n  };\n}\n","/**\n * @flow\n */\n\nexport function createDiodeQuery(\n  Query,\n  fragmentStructure,\n  paramsStructure = {}\n) {\n  if (typeof Query.type !== \"string\") {\n    throw new TypeError(\"Expected query definition to have query type\");\n  }\n\n  if (typeof Query.request !== \"function\") {\n    throw new TypeError(\"Expected query definition to have .request() method\");\n  }\n\n  if (typeof Query.resolve !== \"function\") {\n    throw new TypeError(\"Expected query definition to have .resolve() method\");\n  }\n\n  const query = Object.create(Query);\n  query.fragmentStructure = fragmentStructure;\n  query.paramsStructure = paramsStructure;\n  return query;\n}\n","import find from \"lodash.find\";\nimport createBatchQueryRequest from \"./createBatchQueryRequest\";\n\n/**\n * Given a set of query requests, filter and transform some queries\n * as BatchQuery (if applicable).\n *\n * If BatchQuery types is incomplete, send the queries as normal query\n */\nexport function filterBatchQuery(\n  queries,\n  batchQuery,\n  options\n) {\n  let filteredQueries = [];\n  const { queryTypes, forceMerge } = batchQuery;\n\n  const batchQueryList = queryTypes\n    .map(type => find(queries, { type }))\n    .filter(query => Boolean(query));\n\n  // We need to make sure the queries listed has same length as\n  // query requirements in queryTypes. We can use forceMerge to bypass\n  // this checking but be warned that by using forceMerge, you can no\n  // longer rely on query requirements order in request() method\n  if (\n    batchQueryList.length === queryTypes.length ||\n    // if forceMerge is enabled, make sure at least one query satisfied\n    // the requirement to prevent zero query length\n    (forceMerge && batchQueryList.length > 0)\n  ) {\n    const batchQueryRequest = createBatchQueryRequest(\n      batchQuery,\n      batchQueryList,\n      options\n    );\n    filteredQueries.push(batchQueryRequest);\n  } else {\n    // incomplete batch query, send each query individually\n    filteredQueries = filteredQueries.concat(batchQueryList);\n  }\n\n  const normalQueryList = queries.filter(query => {\n    return batchQueryList.indexOf(query) === -1;\n  });\n\n  filteredQueries = filteredQueries.concat(normalQueryList);\n  return filteredQueries;\n}\n","import find from \"lodash.find\";\nimport objectAssign from \"object-assign\";\n\n/**\n * Parse batch query response and assign the response to each\n * initial queries before filtered as batch queryType\n */\nexport default function resolveBatchQuery(\n  batchResponse,\n  initialQueries,\n  options\n) {\n  const responseMap = {};\n\n  for (const queryType in batchResponse) {\n    /* istanbul ignore else */\n    if (batchResponse.hasOwnProperty(queryType)) {\n      const queryResponse = batchResponse[queryType];\n      const query = find(initialQueries, { type: queryType });\n\n      // Special treatment for __additional property in batch query response.\n      // This is used internally so only remove this if statement when you\n      // know what you're doing\n      if (queryType === \"__additional\") {\n        const specialResponse = { __additional: queryResponse };\n        objectAssign(responseMap, specialResponse);\n      } else if (queryResponse && query) {\n        const { resolve, fragment } = query;\n        responseMap[queryType] = resolve(queryResponse, fragment, options);\n      }\n    }\n  }\n\n  return responseMap;\n}\n","function resolvePendingQuery(pendingQuery, response) {\n  const { callback, dependencies } = pendingQuery;\n\n  const resolvedDependencies = dependencies\n    .map(query => {\n      return response[query.type];\n    })\n    .filter(response => Boolean(response));\n\n  if (resolvedDependencies.length === dependencies.length) {\n    // all dependencies resolvedDependencies\n    // eslint-disable-next-line callback-return\n    const queryRequestInfo = callback(...resolvedDependencies);\n    const queryRequest = generateQueryRequest(pendingQuery, queryRequestInfo);\n\n    // After resolving initial query dependencies, it's possible that the query\n    // still return pending query which can be resolved using initial response.\n    if (queryRequest.dependencies) {\n      return resolvePendingQuery(queryRequest, response);\n    }\n\n    return queryRequest;\n  } else {\n    return pendingQuery;\n  }\n}\n\nexport default function resolvePendingQueries(\n  pendingQueries,\n  response\n) {\n  return pendingQueries.map(pendingQuery => {\n    return resolvePendingQuery(pendingQuery, response);\n  });\n}\n","import find from \"lodash.find\";\nimport DiodeQueryTypes from \"./DiodeQueryTypes\";\nimport resolveBatchQuery from \"./resolveBatchQuery\";\n\nexport default function resolveQueryResponse(\n  queries,\n  initialQueries,\n  queryResponseMap,\n  options\n) {\n  return Object.keys(queryResponseMap).reduce((map, type) => {\n    const queryResponse = queryResponseMap[type];\n    const query = find(queries, { type });\n\n    if (type === DiodeQueryTypes.BATCH) {\n      // BatchQuery returns multiple response at once as single object,\n      // we need to merge initial response with response generated by\n      // batch query response resolution\n      const batchQueryResponseMap = resolveBatchQuery(\n        query.resolve(queryResponse, options),\n        initialQueries,\n        options\n      );\n      Object.assign(map, batchQueryResponseMap);\n    } else {\n      map[type] = query.resolve(queryResponse, query.fragment, options);\n    }\n\n    return map;\n  }, {});\n}\n","/**\n * @flow\n */\nimport deepExtend from \"deep-extend\";\nimport resolveContainerProps from \"../container/resolveContainerProps\";\nimport DiodeNetworkLayer from \"../network/DiodeNetworkLayer\";\nimport DiodeRootQuery from \"../query/DiodeRootQuery\";\nimport resolvePendingQueries from \"../query/resolvePendingQueries\";\nimport resolveQueryResponse from \"../query/resolveQueryResponse\";\nimport { filterBatchQuery } from \"../query/filterBatchQuery\";\nimport {\n  getQueryRequests,\n  generateQueryRequest\n} from \"../query/DiodeQueryRequest\";\nimport { FETCH_ALL_CACHE } from \"../cache/DiodeCache\";\n\nfunction markFetchAllCache(response, queries) {\n  // mark special fetch-all case so our cache is aware\n  queries.forEach(query => {\n    Object.keys(query.fragment).forEach(fragmentKey => {\n      const fragmentResponse = response[query.type][fragmentKey];\n      if (\n        Object.keys(query.fragment[fragmentKey]).length === 0 &&\n        fragmentResponse\n      ) {\n        fragmentResponse[FETCH_ALL_CACHE] = true;\n      }\n    });\n  });\n\n  return response;\n}\n\nclass DiodeStore {\n  _networkLayer;\n\n  _batchQueryEnabled;\n\n  _batchQuery;\n\n  constructor() {\n    this._batchQueriesEnabled = false;\n    this._networkLayer = new DiodeNetworkLayer();\n  }\n\n  /**\n   * @public\n   */\n  injectNetworkLayer(networkLayer) {\n    this._networkLayer.injectNetworkLayer(networkLayer);\n  }\n\n  /**\n   * @public\n   */\n  useMockQueries(queryMockResolver) {\n    this._networkLayer.injectQueryMockResolver(queryMockResolver);\n  }\n\n  /**\n   * @public\n   */\n  useBatchQuery(batchQuery) {\n    /* istanbul ignore else */\n    if (batchQuery) {\n      this._batchQueryEnabled = true;\n      this._batchQuery = batchQuery;\n    }\n  }\n\n  /**\n   * @public\n   *\n   * Send queries via network layer bypassing internal cache. Note that the\n   * server may respond with 304 status but it's not actually an internal\n   * cached response\n   */\n  forceFetch(RootContainer, options) {\n    const queries = getQueryRequests(RootContainer, options);\n    return this._fetchQueries(queries, options).then(response => {\n      const result = resolveContainerProps(response, RootContainer);\n      return markFetchAllCache(result, queries);\n    });\n  }\n\n  filterCachedFragments(query) {\n    const cache = this.cache[query.type];\n\n    if (!cache) {\n      return query;\n    }\n\n    const filteredFragments = {};\n    Object.keys(query.fragment).forEach(fragmentKey => {\n      const cachedFragment = cache[fragmentKey];\n      const innerFragment = query.fragment[fragmentKey];\n      const innerFragmentKeys = Object.keys(innerFragment);\n\n      if (innerFragmentKeys.length === 0) {\n        // fetch all\n        if (cachedFragment && !cachedFragment[FETCH_ALL_CACHE]) {\n          filteredFragments[fragmentKey] = {};\n        }\n        return;\n      }\n\n      // this query type might be partially cached\n      // check specific fragment\n      filteredFragments[fragmentKey] = {};\n      innerFragmentKeys.forEach(innerKey => {\n        if (cachedFragment && cachedFragment[innerKey]) {\n          return;\n        }\n\n        filteredFragments[fragmentKey][innerKey] = innerFragment[innerKey];\n      });\n    });\n\n    return {\n      ...query,\n      fragment: filteredFragments\n    };\n  }\n\n  async fetch(rawQuery, options) {\n    const rootQuery = new DiodeRootQuery(rawQuery);\n    const queries = rootQuery\n      .compile()\n      .map(query => {\n        const { fragment, params } = this.filterCachedFragments(query);\n        if (Object.keys(fragment).length === 0) {\n          return null;\n        }\n\n        const queryRequestInfo = query.request(fragment, params, options);\n        return generateQueryRequest(query, queryRequestInfo);\n      })\n      .filter(Boolean);\n\n    const response = await this._fetchQueries(queries, options);\n    deepExtend(this.cache, markFetchAllCache(response, queries));\n  }\n\n  /**\n   * Recursively fetch over query dependency, starting with query with no\n   * dependency, and build response moving up\n   *\n   * TODO:\n   *  - All DiodeQueryRequest should contain pending property for filtering\n   *    instead of using query.dependencies which is not available in normal\n   *    QueryRequest\n   */\n  _fetchQueries(\n    allQueries,\n    options= {}\n  ) {\n    // We need to store unmodified initial queries before filtered\n    // into batch query so we can use their resolve function when resolving\n    // response from batch query\n    const pendingQueries = allQueries.filter(query => query.dependencies);\n    const initialQueries = allQueries.filter(query => !query.dependencies);\n    let queries = initialQueries;\n\n    if (this._batchQueryEnabled) {\n      queries = filterBatchQuery(queries, this._batchQuery, options);\n    }\n\n    return this._networkLayer\n      .sendQueries(queries, options)\n      .then(queryResponseMap => {\n        const responseMap = resolveQueryResponse(\n          queries,\n          initialQueries,\n          queryResponseMap,\n          options\n        );\n\n        if (pendingQueries.length > 0) {\n          const nextQueries = resolvePendingQueries(\n            pendingQueries,\n            responseMap\n          );\n          return this._fetchQueries(nextQueries, options).then(\n            nextResponseMap => {\n              return Object.assign(responseMap, nextResponseMap);\n            }\n          );\n        }\n\n        return responseMap;\n      });\n  }\n}\n\nexport default new DiodeStore();\n","import axios from \"axios\";\n\nclass DiodeDefaultNetworkLayer {\n  _baseApiEndpoint;\n\n  _defaultHeaders;\n\n  // TODO accept fetch options\n  constructor(baseApiEndpoint, options) {\n    this._baseApiEndpoint = baseApiEndpoint;\n    this._defaultHeaders = {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    };\n  }\n\n  /**\n   * @public\n   *\n   */\n  sendQueries(queryRequests, options) {\n    const requests = queryRequests.map(query => {\n      /* istanbul ignore next */\n      const headers = options.headers ? options.headers : this._defaultHeaders;\n      const { url, method, payload } = query;\n      const apiUrl = `${this._baseApiEndpoint}${url}`;\n      const fetchParams = {\n        url: apiUrl,\n        method,\n        headers: {\n          ...headers,\n          ...query.headers\n        }\n      };\n\n      /* istanbul ignore else */\n      if (typeof payload === \"object\") {\n        // we use JSON.stringify here because this is what most POST request\n        // body looked like. GET requests are usually in form of query string\n        // which should already handled inside apiUrl. Other type of payload,\n        // like urlencodedform should be generated inside query.generate method\n        fetchParams.data = JSON.stringify(payload);\n      } else if (typeof payload === \"string\") {\n        fetchParams.data = payload;\n      }\n\n      return axios(fetchParams).then(response => {\n        return {\n          // ...response,\n          type: query.type,\n          data: response.data,\n        };\n      });\n    });\n\n    return Promise.all(requests).then(responses => {\n      // Convert array of response into Map<QueryType, QueryResponse>\n      const responseMap = responses.reduce((responseMap, response) => {\n        const { type } = response;\n        responseMap[type] = response;\n        return responseMap;\n      }, {});\n\n      return responseMap;\n    });\n  }\n}\n\n// module.exports.default = DiodeDefaultNetworkLayer;\nexport default DiodeDefaultNetworkLayer;\n","module.exports = require(\"@babel/runtime/regenerator\");","module.exports = require(\"axios\");","module.exports = require(\"deep-extend\");","module.exports = require(\"hoist-non-react-statics\");","module.exports = require(\"lodash.find\");","module.exports = require(\"object-assign\");","module.exports = require(\"react\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AARA;AACA;AAUA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AATA;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AACA;;;;;;AACA;;;;;;AAEA;AACA;;AADA;AAEA;AACA;AACA;AAFA;AACA;;AAOA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAEA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAWA;AACA;;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AAtCA;AACA;AAwCA;;;;;;;;;;;;ACvDA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAZA;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AAEA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAOA;AACA;AACA;AATA;AAAA;AAAA;AAYA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;AAAA;AAAA;AAiDA;AACA;AAlDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAyDA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AAFA;AACA;;;;;;;;;;;;;;;;AAKA;AACA;AAEA;;;;;;;;;;AAKA;AACA;;AAAA;AAAA;AAAA;;;;;;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;AA5CA;AACA;AA8CA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AACA;AAKA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAGA;AACA;AAVA;AAAA;AAAA;AAWA;AACA;AADA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAGA;AA9BA;AACA;AADA;AAAA;AACA;AAgCA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;;;;;;;;;;;;AC7IA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AACA;AAEA;AAIA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AADA;AAAA;AACA;AAEA;AACA;AACA;AACA;AANA;AACA;AAQA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;AACA;;;AAKA;AAAA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AAEA;;;;;;;;;AAKA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;ACnEA;;;AAGA;AAEA;;;;;AAIA;;;AACA;AAGA;AAOA;AAIA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;AAEA;;;;;;;;;AAMA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAKA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;ACjKA;;;;AAIA;;;;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;;;;;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;;;;;AAIA;AAIA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAKA;AAGA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAHA;AAMA;;;;;;;;;;;;AC5EA;AAAA;AACA;AADA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;;;AAGA;AAEA;;;;;AAIA;;;AAIA;AAAA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AAEA;;;;;;;;AAIA;AACA;AACA;AAEA;;;;;;;AAIA;AACA;AACA;AAEA;;;;;;;AAIA;AACA;AACA;AAEA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;ACnGA;AAIA;AAAA;AAGA;AACA;AACA;AAFA;AAKA;;;;;;;;;;;;ACZA;AAAA;AAAA;;;AAIA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;AAMA;AAKA;AADA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAOA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AAEA;;;;;;;AAGA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAFA;AAIA;;;;;;AAEA;;;;;;;;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AADA;AACA;AACA;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;AAUA;AAEA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAMA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;;;AAKA;AACA;AAAA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AAEA;;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAHA;AASA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;AAGA;AACA;AACA;AADA;;;;;;;;;;;;;;;;;;;;;;;ACrEA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}