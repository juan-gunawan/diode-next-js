{"version":3,"file":"static/webpack/static/development/pages/index.js.a442be1b548287f5d034.hot-update.js","sources":["webpack:///./react-diode/src/store/DiodeStore.js"],"sourcesContent":["/**\n * @flow\n */\nimport deepExtend from \"deep-extend\";\nimport resolveContainerProps from \"../container/resolveContainerProps\";\nimport DiodeNetworkLayer from \"../network/DiodeNetworkLayer\";\nimport DiodeRootQuery from \"../query/DiodeRootQuery\";\nimport resolvePendingQueries from \"../query/resolvePendingQueries\";\nimport resolveQueryResponse from \"../query/resolveQueryResponse\";\nimport { filterBatchQuery } from \"../query/filterBatchQuery\";\nimport {\n  getQueryRequests,\n  generateQueryRequest\n} from \"../query/DiodeQueryRequest\";\nimport { FETCH_ALL_CACHE } from \"../cache/DiodeCache\";\n\nfunction markFetchAllCache(response, queries) {\n  // console.log('MARK_FETCH', response);\n  // mark special fetch-all case so our cache is aware\n  queries.forEach(query => {\n    Object.keys(query.fragment).forEach(fragmentKey => {\n      const fragmentResponse = response[query.type][fragmentKey];\n      if (\n        Object.keys(query.fragment[fragmentKey]).length === 0 &&\n        fragmentResponse\n      ) {\n        fragmentResponse[FETCH_ALL_CACHE] = true;\n      }\n    });\n  });\n\n  return response;\n}\n\nclass DiodeStore {\n  _networkLayer;\n\n  _batchQueryEnabled;\n\n  _batchQuery;\n\n  constructor() {\n    this._batchQueriesEnabled = false;\n    this._networkLayer = new DiodeNetworkLayer();\n  }\n\n  /**\n   * @public\n   */\n  injectNetworkLayer(networkLayer) {\n    this._networkLayer.injectNetworkLayer(networkLayer);\n  }\n\n  /**\n   * @public\n   */\n  useMockQueries(queryMockResolver) {\n    this._networkLayer.injectQueryMockResolver(queryMockResolver);\n  }\n\n  /**\n   * @public\n   */\n  useBatchQuery(batchQuery) {\n    /* istanbul ignore else */\n    if (batchQuery) {\n      this._batchQueryEnabled = true;\n      this._batchQuery = batchQuery;\n    }\n  }\n\n  /**\n   * @public\n   *\n   * Send queries via network layer bypassing internal cache. Note that the\n   * server may respond with 304 status but it's not actually an internal\n   * cached response\n   */\n  forceFetch(RootContainer, options) {\n    const queries = getQueryRequests(RootContainer, options);\n    return this._fetchQueries(queries, options).then(response => {\n      // console.log('FORCE_FETCH', response)\n      const result = resolveContainerProps(response, RootContainer);\n      return markFetchAllCache(result, queries);\n    });\n  }\n\n  filterCachedFragments(query) {\n    const cache = this.cache[query.type];\n\n    if (!cache) {\n      return query;\n    }\n\n    const filteredFragments = {};\n    Object.keys(query.fragment).forEach(fragmentKey => {\n      const cachedFragment = cache[fragmentKey];\n      const innerFragment = query.fragment[fragmentKey];\n      const innerFragmentKeys = Object.keys(innerFragment);\n\n      if (innerFragmentKeys.length === 0) {\n        // fetch all\n        if (cachedFragment && !cachedFragment[FETCH_ALL_CACHE]) {\n          filteredFragments[fragmentKey] = {};\n        }\n        return;\n      }\n\n      // this query type might be partially cached\n      // check specific fragment\n      filteredFragments[fragmentKey] = {};\n      innerFragmentKeys.forEach(innerKey => {\n        if (cachedFragment && cachedFragment[innerKey]) {\n          return;\n        }\n\n        filteredFragments[fragmentKey][innerKey] = innerFragment[innerKey];\n      });\n    });\n\n    return {\n      ...query,\n      fragment: filteredFragments\n    };\n  }\n\n  async fetch(rawQuery, options) {\n    const rootQuery = new DiodeRootQuery(rawQuery);\n    const queries = rootQuery\n      .compile()\n      .map(query => {\n        const { fragment, params } = this.filterCachedFragments(query);\n        if (Object.keys(fragment).length === 0) {\n          return null;\n        }\n\n        const queryRequestInfo = query.request(fragment, params, options);\n        return generateQueryRequest(query, queryRequestInfo);\n      })\n      .filter(Boolean);\n\n    const response = await this._fetchQueries(queries, options);\n    deepExtend(this.cache, markFetchAllCache(response, queries));\n  }\n\n  /**\n   * Recursively fetch over query dependency, starting with query with no\n   * dependency, and build response moving up\n   *\n   * TODO:\n   *  - All DiodeQueryRequest should contain pending property for filtering\n   *    instead of using query.dependencies which is not available in normal\n   *    QueryRequest\n   */\n  _fetchQueries(\n    allQueries,\n    options= {}\n  ) {\n    // We need to store unmodified initial queries before filtered\n    // into batch query so we can use their resolve function when resolving\n    // response from batch query\n    const pendingQueries = allQueries.filter(query => query.dependencies);\n    const initialQueries = allQueries.filter(query => !query.dependencies);\n    let queries = initialQueries;\n\n    if (this._batchQueryEnabled) {\n      queries = filterBatchQuery(queries, this._batchQuery, options);\n    }\n\n    return this._networkLayer\n      .sendQueries(queries, options)\n      .then(queryResponseMap => {\n        const responseMap = resolveQueryResponse(\n          queries,\n          initialQueries,\n          queryResponseMap,\n          options\n        );\n\n        if (pendingQueries.length > 0) {\n          const nextQueries = resolvePendingQueries(\n            pendingQueries,\n            responseMap\n          );\n          return this._fetchQueries(nextQueries, options).then(\n            nextResponseMap => {\n              return Object.assign(responseMap, nextResponseMap);\n            }\n          );\n        }\n\n        return responseMap;\n      });\n  }\n}\n\nexport default new DiodeStore();\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAOA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AAEA;;;;;;;AAGA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAFA;AAIA;;;;;;AAEA;;;;;;;;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AADA;AACA;AACA;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;AAUA;AAEA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAMA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;A","sourceRoot":""}